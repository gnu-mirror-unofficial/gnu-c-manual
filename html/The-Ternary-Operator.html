<html lang="en">
<head>
<title>The Ternary Operator - The GNU C Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Reference Manual">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Expressions-and-Operators.html#Expressions-and-Operators" title="Expressions and Operators">
<link rel="prev" href="Binary-Operators.html#Binary-Operators" title="Binary Operators">
<link rel="next" href="Order-of-Evaluation.html#Order-of-Evaluation" title="Order of Evaluation">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This is the GNU C reference manual.

Copyright (C) 2007 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You are free to copy and modify
     this GNU Manual.  Buying copies from GNU Press supports the FSF in
     developing GNU and promoting software freedom.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="The-Ternary-Operator"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Order-of-Evaluation.html#Order-of-Evaluation">Order of Evaluation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Binary-Operators.html#Binary-Operators">Binary Operators</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Expressions-and-Operators.html#Expressions-and-Operators">Expressions and Operators</a>
<hr>
</div>

<h3 class="section">3.4 The Ternary Operator</h3>

<p><a name="index-ternary-operator_002c-the-186"></a><a name="index-operator_002c-ternary-187"></a><a name="index-conditional-operator-188"></a>
C has only one ternary operator &mdash; the conditional operator <code>? :</code>.

   <p>You use the conditional operator to cause the entire conditional
expression to evaluate to either its second or its third operand, based
on the truth value of its first operand.

   <p>Put the first operand is before the question mark; this operand
may be any expression.  If it evaluates to true (nonzero), then
the second operand (which is also an expression), which is placed
in between the question mark and the colon, is evaluated, and
becomes the value of the conditional expression.  Otherwise, the third
operand (also an expression), which is placed after the colon, is
evaluated, and becomes the value of the conditional expression.  Here
is an example

<pre class="example">     a = (x == 5) ? y : z;
</pre>
   <p>In that example, if <code>x</code> equals 5, then <code>a</code> will receive
the value <code>y</code>.  Otherwise, <code>a</code> will receive the value
<code>z</code>.  Really, this is a shorthand method for writing a simple
<code>if</code><small class="dots">...</small><code>else</code> statement.  The previous example will
accomplish the same task as the following example:

<pre class="example">     if( x != 0)
         a = y;
     else
         a = z;
</pre>
   <p>If the first operand of the conditional operator is true, then the third
operand is never evaluated.  Similarly, if the first operand is false,
then the second operand is never evaluated.  The first operand is always
evaluated.

   <p>You can also leave out the second operand &mdash; this is similar to using the
first operand as both the first operand <em>and</em> the second operand.  For
example, the expression

<pre class="example">     x ? : y
</pre>
   <p class="noindent">has the same value as

<pre class="example">     x ? x : y
</pre>
   <p>In simple examples like that one, there is no point to leaving out the
second operand.  However, if the first operand had a side effect, such
as incrementing a variable, then you might not want that side effect to
happen twice, so you shouldn't include it as both the first and second
operands.

<!-- GNU C Extension -->
<!-- @node Statements and Declarations in Expressions -->
<!-- @section Statements and Declarations in Expressions -->
<!-- @cindex statements inside expressions -->
<!-- @cindex declarations inside expressions -->
<!-- @cindex expressions containing statements -->
<!-- @cindex macros, statements in expressions -->
<!-- A compound statement enclosed in parentheses may appear as an expression -->
<!-- in GNU C.  This allows you to use loops, switches, and local variables -->
<!-- within an expression. -->
<!-- Recall that a compound statement (also known as a block) is a sequence of -->
<!-- statements surrounded by braces; in this construct, parentheses go around -->
<!-- the braces.  Here is an example: -->
<!-- @example -->
<!-- @group -->
<!-- (@{ int y = function (); int z; -->
<!-- if (y > 0) z = y; -->
<!-- else z = - y; -->
<!-- z; @}) -->
<!-- @end group -->
<!-- @end example -->
<!-- That is a valid (though slightly more complex than necessary) expression -->
<!-- for the absolute value of @code{function ()}. -->
<!-- The last thing in the compound statement should be an expression -->
<!-- followed by a semicolon; the value of this subexpression serves as the -->
<!-- value of the entire construct.  (If you use some other kind of statement -->
<!-- last within the braces, the construct has type @code{void}, and thus -->
<!-- effectively no value.) -->
<!-- This feature is especially useful in making macro definitions ``safe'' (so -->
<!-- that they evaluate each operand exactly once).  For example, the -->
<!-- ``maximum'' function is commonly defined as a macro in standard C as -->
<!-- follows: -->
<!-- @example -->
<!-- #define max(a,b) ((a) > (b) ? (a) : (b)) -->
<!-- @end example -->
<!-- @noindent -->
<!-- @cindex side effects, macro argument -->
<!-- But this definition computes either @code{a} or @code{b} twice, with bad -->
<!-- results if the operand has side effects.  In GNU C, if you know the -->
<!-- type of the operands (here let's assume @code{int}), you can define -->
<!-- the macro safely as follows: -->
<!-- @example -->
<!-- #define maxint(a,b) \ -->
<!-- (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @}) -->
<!-- @end example -->
<!-- Embedded statements are not allowed in constant expressions, such as -->
<!-- the value of an enumeration constant, the width of a bit field, or -->
<!-- the initial value of a static variable. -->
<!-- If you don't know the type of the operand, you can still do this, but you -->
<!-- must use @code{typeof} expressions or type naming. -->
<!-- Add reference to typeof typedef -->
</body></html>

